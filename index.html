<html lang="en">
<!-- quite clos but still stress work, tabs TODO -->
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SOFA | A MacAdmin's Simple Organized Feed for Apple Software Updates</title>
  <link href="./main.css" rel="stylesheet">
  <style>
    .text-content {
      padding-right: 80px;
      /* Adjust the padding to ensure text does not overlap the image */
    }

    .os-image {
      position: absolute;
      top: -30px;
      /* Adjust the position to let the image float on top */
      right: 15px;
      height: 60px;
      /* Adjust the size of the image as needed */
      width: auto;
      border-radius: 50%;
      /* Circular image */
    }

    /* Light mode styles as default */
.highlight-cve {
    background-color: rgb(227, 159, 32); /* Light mode color */
    box-shadow: 0 0 1px 1px rgb(227, 159, 32);
}

/* Dark mode styles */
html.dark .highlight-cve {
    background-color: rgb(154, 25, 70); /* Dark mode color */
    box-shadow: 0 0 1px 1px rgb(154, 25, 70);
}
    /* Any additional custom styles */
  </style>
</head>

<body class="bg-gray-50 text-gray-700 dark:bg-gray-900 dark:text-gray-300 font-sans">
  <div class="container mx-auto px-6 py-12">
    <div class="flex items-center justify-between mb-6">
      <div class="flex items-center">
        <img src="images/custom_logo.png" alt="Custom Logo" class="h-20 w-20 mr-4 sm:mr-6">
        <h1 class="text-3xl font-bold text-grey-900 dark:text-grey-100">SOFA | Simple Organized Feed for Apple Software Updates</h1>
      </div>
      <!-- Theme Toggle Button -->
      <button id="theme-toggle" data-tooltip-target="tooltip-toggle" type="button" class="inline-flex items-center justify-center hover:bg-gray-100 dark:hover:bg-gray-800 rounded-lg w-10 h-10">
        <svg id="theme-toggle-dark-icon" class="w-4 h-4 hidden" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 18 20">
          <path d="M17.8 13.75a1 1 0 0 0-.859-.5A7.488 7.488 0 0 1 10.52 2a1 1 0 0 0 0-.969A1.035 1.035 0 0 0 9.687.5h-.113a9.5 9.5 0 1 0 8.222 14.247 1 1 0 0 0 .004-.997Z"></path>
        </svg>
        <svg id="theme-toggle-light-icon" class="w-4 h-4" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 20 20">
          <path d="M10 15a5 5 0 1 0 0-10 5 5 0 0 0 0 10Zm0-11a1 1 0 0 0 1-1V1a1 1 0 0 0-2 0v2a1 1 0 0 0 1 1Zm0 12a1 1 0 0 0-1 1v2a1 1 0 1 0 2 0v-2a1 1 0 0 0-1-1ZM4.343 5.757a1 1 0 0 0 1.414-1.414L4.343 2.929a1 1 0 0 0-1.414 1.414l1.414 1.414Zm11.314 8.486a1 1 0 0 0-1.414 1.414l1.414 1.414a1 1 0 0 0 1.414-1.414l-1.414-1.414ZM4 10a1 1 0 0 0-1-1H1a1 1 0 0 0 0 2h2a1 1 0 0 0 1-1Zm15-1h-2a1 1 0 1 0 0 2h2a1 1 0 0 0 0-2ZM4.343 14.243l-1.414 1.414a1 1 0 1 0 1.414 1.414l1.414-1.414a1 1 0 0 0-1.414-1.414ZM14.95 6.05a1 1 0 0 0 .707-.293l1.414-1.414a1 1 0 1 0-1.414-1.414l-1.414 1.414a1 1 0 0 0 .707 1.707Z"></path>
        </svg>
      </button>
    </div>
    <div class="flex flex-col sm:flex-row justify-between items-center mb-6">
      <div id="tabs" class="mb-6 flex"></div>
      <!-- Adjust search input colors for light mode -->
      <div class="relative mb-4">
        <input type="search" id="searchInput" placeholder="Search CVEs..." class="h-10 bg-gray-100 text-gray-900 placeholder-gray-500 dark:bg-gray-800 dark:text-white dark:placeholder-gray-400 pl-10 pr-4 rounded-lg border-2 border-gray-300 dark:border-gray-700 focus:outline-none focus:border-indigo-500">
        <div class="absolute top-0 left-0 mt-2 ml-3">
          <svg class="text-gray-600 dark:text-gray-400 h-6 w-6" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" stroke="currentColor">
            <path d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
          </svg>
        </div>
      </div>
    </div>
    <!-- Adjust informational text colors for light mode -->
    <div id="last-checked" class="mb-2 text-indigo-700 dark:text-indigo-400"></div>
    <div id="machine-readable-feed" class="text-indigo-700 dark:text-indigo-400 mb-6"></div>
     <!-- New container for both the version card and XProtect card -->
  <div class="grid md:grid-cols-2 gap-4">
    <!-- Container for the OS version information -->
    <div id="version-card"></div>
    
    <!-- Container for the XProtect information -->
    <div id="xprotect-card"></div>
  </div>
    <!-- <div class="grid md:grid-cols-2 gap-4" id="version-card"></div> -->
    <hr class="border-t-2 border-gray-300 dark:border-gray-700 my-8">
    <div id="security-releases" class="space-y-4">
      <!-- Adjust headings and link colors for light mode -->
      <h2 class="text-2xl text-indigo-700 dark:text-indigo-400 font-semibold mb-4">Apple Resources</h2>
      <a href="https://support.apple.com/en-us/HT201222" class="text-blue-600 hover:text-blue-400 dark:text-yellow-500 dark:hover:text-yellow-300 text-lg">Apple security releases</a>
    </div>
  </div>


<script>
    document.addEventListener('DOMContentLoaded', async() => {
        // Fetch and set configData before proceeding
        configData = await fetchConfigData();
        if (configData) {
            const orderedData = orderSoftwareReleases(configData);
            createTabs(orderedData); // Now configData is available for use within createTabs

            const themeToggleBtn = document.getElementById('theme-toggle');
            themeToggleBtn.addEventListener('click', toggleTheme);
            setInitialTheme();
            initializeCVEFiltering(); // Assuming this function does not directly depend on configData
        } else {
            console.error('Failed to load configuration data.');
        }
    });

    async function fetchConfigData() {
        try {
            const response = await fetch('./config.json');
            if (!response.ok) {
                throw new Error(`Failed to fetch config data: HTTP status ${response.status}`);
            }
            return await response.json();
        } catch (error) {
            console.error('Error fetching configuration:', error);
            return null; // Return null to indicate failure
        }
    }

    async function createTabs(orderedData) {
        // Assuming configData is available here, either through closure or global variable
        const tabsContainer = document.getElementById('tabs');
        tabsContainer.innerHTML = '';
        const activeTabId = localStorage.getItem('activeTabId');

        orderedData.forEach(software => {
            const button = document.createElement('button');
            // Check if the software is of type 'iOS' and prepend 'iOS ' to the name
            const softwareName = software.osType === 'iOS' ? `iOS ${software.name}` : software.name;
            button.textContent = softwareName;
            button.dataset.id = software.id;
            button.className = getClassNames(software.id.toString() === activeTabId);
            button.addEventListener('click', async() => {
                setActiveTab(button);
                // Determine the correct data feed path based on osType
                const dataFeedPath = configData.globalSettings.dataFeedFiles[software.osType];
                if (dataFeedPath) {
                    await fetchData(`./${dataFeedPath}`, software.osType, softwareName);
                } else {
                    console.error("Data feed path not found for osType:", software.osType);
                }
            });
            tabsContainer.appendChild(button);
        });

        const initialTab = tabsContainer.querySelector(`[data-id="${activeTabId}"]`) || tabsContainer.firstChild;
        if (initialTab) initialTab.click();
    }

    function getClassNames(isActive) {
        return `px-4 py-2 rounded-lg mr-2 font-medium transition duration-150 ease-in-out ${isActive ? 'bg-indigo-600 text-white dark:bg-indigo-500' : 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300'} hover:bg-indigo-500 dark:hover:bg-indigo-400`;
    }

    function setActiveTab(activeTab) {
        document.querySelectorAll('#tabs button').forEach(btn => {
            btn.className = getClassNames(false); // Reset all to inactive state
        });
        activeTab.className = getClassNames(true); // Set active state
        localStorage.setItem('activeTabId', activeTab.dataset.id); // Save active tab ID
    }

    async function fetchData(dataFeedPath, osType, osVersionName) {
        try {
            // Correcting the file path construction
            const fullPath = `./v1/${dataFeedPath}`; // Assuming dataFeedPath is correctly provided from config
            console.log("Full Path:", fullPath);

            const response = await fetch(fullPath);
            if (!response.ok) {
                throw new Error(`Failed to fetch data from ${fullPath}: ${response.statusText}`);
            }
            const data = await response.json();

            // Adjusting the version name matching logic
            // For iOS, we're stripping out non-numeric characters to match against version numbers like "17"
            const versionNameFormatted = osType.toLowerCase() === 'ios' ?
                osVersionName.replace(/[^\d]/g, '') :
                osVersionName;

            console.log("Version Name Formatted:", versionNameFormatted);

            // Attempting to find the specific version data
            const specificVersionData = data.OSVersions.find(version => {
                // For iOS, we're directly comparing the cleaned version number
                return osType.toLowerCase() === 'ios' ?
                    version.OSVersion === versionNameFormatted :
                    version.OSVersion.toLowerCase().includes(versionNameFormatted.toLowerCase());
            });

            if (specificVersionData) {
                console.log("Found specific OS version data:", specificVersionData);
                updateUIWithOSData(specificVersionData, osType, data);
            } else {
                console.error(`Specific OS version data not found for: ${osVersionName}`);
                // Optionally handle fallback here
            }
        } catch (error) {
            console.error('Error in fetchData:', error);
        }
    }

    function orderSoftwareReleases(configData) {
        const {
            softwareReleases,
            globalSettings: {
                buttonOrder
            }
        } = configData;
        // Map to get order index for OS types
        const orderIndex = buttonOrder.reduce((acc, osType, index) => ({
            ...acc,
            [osType]: index
        }), {});
        // Sort by OS type order, then by id within each type
        return softwareReleases.sort((a, b) => {
            const typeOrderDiff = orderIndex[a.osType] - orderIndex[b.osType];
            if (typeOrderDiff !== 0) return typeOrderDiff;
            // Assuming 'id' is numeric and directly comparable
            return a.id - b.id;
        });
    }

    function updateUIWithOSData(specificVersionData, osType, fullData) {
        // Update the "Last Checked" and "Machine Readable Feed" sections
        document.getElementById('last-checked').innerHTML = `Last checked: <span class="text-indigo-700 dark:text-indigo-300">${fullData.lastCheck}</span>`;
        const fullPath = `v1/${osType}_data_feed.json`;
        document.getElementById('machine-readable-feed').innerHTML = `Machine readable feed: <a href="${createSafeLink('v1/' + osType.toLowerCase() + '_data_feed.json')}" class="text-blue-600 hover:text-blue-400 dark:text-yellow-500 dark:hover:text-yellow-300">v1/${osType.toLowerCase()}_data_feed.json</a>`;

        // Populate the version card with specific version data
        populateVersionCard(specificVersionData, osType);

        // Populate security releases if available
        if (specificVersionData.SecurityReleases) {
            populateSecurityReleases(specificVersionData.SecurityReleases, osType);
        }

        // Determine and display OS version links if applicable
        const osVersion = determineOSVersion(specificVersionData, osType);
        if (osVersion) {
            fetchAndDisplayOSLinks(osType, osVersion);
        } else {
            console.error("Unable to determine OS version for linking.");
        }

        // Populate XProtect data if available and applicable to macOS, otherwise clear the XProtect card
        if (osType.toLowerCase() === 'macos' && fullData.XProtectPayloads && fullData.XProtectPlistConfigData) {
            populateXProtectCard(fullData.XProtectPlistConfigData, fullData.XProtectPayloads);
        } else {
            // Clear the XProtect card content for non-macOS OS types
            document.getElementById('xprotect-card').innerHTML = '';
        }

        // Initialize CVE filtering for security releases
        initializeCVEFiltering();
    }

    function toggleTheme() {
        const isDark = document.documentElement.classList.toggle('dark');
        localStorage.setItem('theme', isDark ? 'dark' : 'light');
        updateThemeIcon();
    }

    function setInitialTheme() {
        const isDarkMode = localStorage.getItem('theme') === 'dark' || (window.matchMedia('(prefers-color-scheme: dark)').matches && !localStorage.getItem('theme'));
        document.documentElement.classList.toggle('dark', isDarkMode);
        updateThemeIcon();
    }

    function updateThemeIcon() {
        const themeToggleDarkIcon = document.getElementById('theme-toggle-dark-icon');
        const themeToggleLightIcon = document.getElementById('theme-toggle-light-icon');
        const isDarkMode = document.documentElement.classList.contains('dark');
        themeToggleDarkIcon.classList.toggle('hidden', !isDarkMode);
        themeToggleLightIcon.classList.toggle('hidden', isDarkMode);
    }

    function determineOSVersion(osData, osType) {
        // Ensure osType is correctly formatted
        const type = osType.toLowerCase();
        // Use the 'OSVersion' property since 'VersionName' does not exist in the provided data
        const osVersion = osData.OSVersion;
        if (!osVersion) {
            console.warn(`OS version not found for ${osType} in provided data:`, osData);
            return 'Unknown Version'; // Return a placeholder or handle this scenario as needed
        }
        // Assuming the OS version naming convention is consistent and does not require additional formatting
        // Directly return the OSVersion value for both macOS and iOS, or adjust formatting as needed
        return osVersion;
    }

    function getImageName(osData, osType) { // osType is added as a parameter
        let imageName = "default.png"; // Default image name
        if (osData && osData.OSVersion) {
            const osVersionParts = osData.OSVersion.split(' ');
            console.log("OS Version Parts:", osVersionParts);
            // Handle macOS and iOS differently
            if (osType.toLowerCase() === "macos") {
                // Assuming the name directly follows "macOS"
                const osName = osVersionParts[0];
                imageName = `${osName}.png`; // Constructs image filename as "Ventura.png"
            } else if (osType.toLowerCase() === "ios") {
                // For iOS, assuming the version number directly follows "iOS"
                const iosVersion = osVersionParts.join('_');
                imageName = `ios_${iosVersion}.png`; // Constructs image filename as "ios_17.png"
            }
        }
        return imageName; // Return the constructed image name or the default
    }

    function populateVersionCard(osData, osType) {
        const versionCardContainer = document.getElementById('version-card');
        if (!versionCardContainer || !osData || !osData.LatestOS) {
            console.error("Version card data is missing or empty.");
            return;
        }
        // Assuming osData is correctly passed as a single version object
        const {
            OSVersion,
            LatestOS
        } = osData;
        const imageName = getImageName(osData, osType); // Adjust getImageName function as needed
        // Clear existing content
        versionCardContainer.innerHTML = '';
        const osSectionHTML = `
    <div class="relative bg-gray-100 dark:bg-gray-800 border border-gray-300 dark:border-gray-600 shadow overflow-hidden sm:rounded-lg p-6 flex flex-col" data-os-version="${OSVersion}">
        <h3 class="text-lg leading-6 font-semibold text-indigo-700 dark:text-indigo-400">${osType} ${OSVersion}</h3>
        <div><strong>Last released version:</strong> ${LatestOS.ProductVersion}</div>
        <div class="mt-2 max-w-xl text-sm text-gray-600 dark:text-gray-400">
            <p><strong>Build:</strong> ${LatestOS.Build}</p>
            <p><strong>Release Date:</strong> ${formatDate(LatestOS.ReleaseDate)}</p>
            <p><strong>Days since release:</strong> ${Math.floor((new Date() - new Date(LatestOS.ReleaseDate)) / (1000 * 60 * 60 * 24))}</p>
        </div>
        <img src="images/${imageName}" alt="${OSVersion}" class="absolute top-6 right-6 h-14 w-auto" onerror="this.onerror=null; this.src='default.png';">
        <div class="mt-8 max-w-xl text-sm text-gray-600 dark:text-gray-400">
            How to Manage Updates: 
            <a href="https://support.apple.com/guide/deployment/use-mdm-to-deploy-software-updates-depafd2fad80/1/web/1.0" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:text-blue-400 dark:text-yellow-500 dark:hover:text-yellow-300">Get to know more</a>
        </div>
        <div class="essential-links mt-4">
            <h4 class="text-lg leading-6 font-semibold text-indigo-700 dark:text-indigo-400">Essential Apple Resources</h4>
            <ul class="links-list" data-os-version="${OSVersion}"></ul>
        </div>
    </div>
    `;
        // Append the generated HTML to the container
        versionCardContainer.innerHTML = osSectionHTML;
    }

    function fetchAndDisplayOSLinks(osType, osFullVersion) {
        console.log(`Fetching links for ${osType}, version: ${osFullVersion}`); // Use osFullVersion for logging
        fetch('essential_links.json')
            .then(response => {
                if (!response.ok) throw new Error('Network response was not OK');
                return response.json();
            })
            .then(data => {
                console.log("Fetched data:", data);
                // No need to split osFullVersion; it should directly match the JSON structure
                const versionKey = osType === 'macOS' ? osFullVersion.split(' ')[0] : osFullVersion;
                const commonLinks = data.Common || {};
                const specificLinks = data[osType] && data[osType][versionKey] ? data[osType][versionKey] : {};
                const mergedLinks = {
                    ...specificLinks,
                    ...commonLinks
                };
                console.log(`Merged Links for ${osType} ${versionKey}:`, mergedLinks);
                if (Object.keys(mergedLinks).length) {
                    console.log(`Displaying links for ${osType} ${versionKey}:`, mergedLinks);
                    populateOSLinks(mergedLinks, osFullVersion); // Pass osFullVersion to align with your HTML structure
                } else {
                    console.error(`No links found for ${osType} ${versionKey}`);
                }
            })
            .catch(error => console.error('Error fetching essential links:', error));
    }

    function populateOSLinks(links, osFullVersion) {
        const linksList = document.querySelector(`.links-list[data-os-version='${osFullVersion}']`);
        if (!linksList) {
            console.error(`No links list found for OS version: ${osFullVersion}`);
            return;
        }

        linksList.classList.add('max-w-xl', 'text-sm');
        linksList.innerHTML = ''; // Clear the list before repopulating it

        Object.entries(links).forEach(([key, url]) => {
            // Sanitize the URL before using it in the href attribute
            const sanitizedUrl = createSafeLink(url);

            // Create a list item and anchor element for each link
            const listItem = document.createElement('li');
            const linkElement = document.createElement('a');
            linkElement.href = sanitizedUrl; // Use the sanitized URL
            linkElement.textContent = key; // Set the link text
            linkElement.setAttribute('target', '_blank');
            linkElement.classList.add('text-blue-600', 'hover:text-blue-400', 'dark:text-yellow-500', 'dark:hover:text-yellow-300');

            // Append the anchor element to the list item, then append the list item to the list
            listItem.appendChild(linkElement);
            linksList.appendChild(listItem);
        });
    }

    function populateXProtectCard(XProtectPlistConfigData, XProtectPayloads) {
        console.log("Populating XProtect Card", {
            XProtectPlistConfigData,
            XProtectPayloads
        });
        const xProtectCardContainer = document.getElementById('xprotect-card');
        if (!xProtectCardContainer) {
            console.error('XProtect card container not found.');
            return;
        }
        // Extracting necessary data directly
        const xProtectVersion = XProtectPlistConfigData["com.apple.XProtect"];
        const xProtectAppVersion = XProtectPayloads["com.apple.XProtectFramework.XProtect"];
        const xProtectRemediatorVersion = XProtectPayloads["com.apple.XprotectFramework.PluginService"];
        const appReleaseDate = XProtectPayloads.ReleaseDate;
        const plistReleaseDate = XProtectPlistConfigData.ReleaseDate;

        const daysSinceAppRelease = Math.floor((new Date() - new Date(appReleaseDate)) / (1000 * 60 * 60 * 24));
        const daysSincePlistRelease = Math.floor((new Date() - new Date(plistReleaseDate)) / (1000 * 60 * 60 * 24));

        const xProtectInfoUrl = "https://support.apple.com/guide/security/protecting-against-malware-sec469d47bd8/web";
        const sanitizedUrl = createSafeLink(xProtectInfoUrl); // Use createSafeLink to sanitize the URL

        const xProtectCardHTML = `
    <div class="relative bg-gray-100 dark:bg-gray-800 border border-gray-300 dark:border-gray-600 shadow overflow-hidden sm:rounded-lg p-6 flex flex-col">
      <h3 class="text-lg leading-6 font-semibold text-indigo-700 dark:text-indigo-400">XProtect data files</h3>
      <div><strong>Latest versions:</strong> ${xProtectAppVersion} | ${xProtectRemediatorVersion} | ${xProtectVersion}</div>
      <div class="mt-2 max-w-xl text-sm text-gray-600 dark:text-gray-400">
        <p><strong>XProtect.app latest version:</strong> ${xProtectAppVersion}</p>
        <p><strong>XProtect Remediator latest version:</strong> ${xProtectRemediatorVersion}</p>
        <p><strong>App Release Date:</strong> ${formatDate(appReleaseDate)}</p>
        <p><strong>Days since release:</strong> ${daysSinceAppRelease}</p>
      </div>
      <div class="mt-4 max-w-xl text-sm text-gray-600 dark:text-gray-400">
          <p><strong>XProtectPlistConfigData latest version:</strong> ${xProtectVersion}</p>
          <p><strong>Plist Release Date:</strong> ${formatDate(plistReleaseDate)}</p>
          <p><strong>Days since release:</strong> ${daysSincePlistRelease}</p>
      </div>
      <div class="mt-8 max-w-xl text-sm text-gray-600 dark:text-gray-400">
        What is XProtect: 
        <a href="${sanitizedUrl}" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:text-blue-400 dark:text-yellow-500 dark:hover:text-yellow-300">Get to know more</a>
      </div>
      <img src="images/SWUpdate.png" alt="SWUpdate" class="absolute top-6 right-6 h-14 w-auto" onerror="this.onerror=null; this.src='default.png';">
    </div>
    `;

        xProtectCardContainer.innerHTML = xProtectCardHTML;
    }


    function populateSecurityReleases(securityReleases, osType) {
        const securityReleasesContainer = document.getElementById('security-releases');
        const headerText = `${osType} Security Updates Overview`;
        securityReleasesContainer.innerHTML = `<h2 class="text-2xl text-indigo-700 dark:text-yellow-500 font-semibold mb-4">${headerText}</h2>`;

        securityReleases.forEach((release, index) => {
            const tooltipText = "Critical security updates included in this release. Please review for impact.";
            const warningSign = release.SecurityInfo.startsWith('http') ? `<span class="text-yellow-400" title="${tooltipText}"> ⚠️</span>` : '';
            const securityInfoHTML = release.SecurityInfo.startsWith('http') ?
                `<a href="${createSafeLink(release.SecurityInfo)}" class="text-blue-600 dark:text-yellow-500 hover:text-blue-400" target="_blank">${release.SecurityInfo}</a>` :
                release.SecurityInfo;

            let cveLinksHTML = Object.keys(release.CVEs).map(cve => {
                const cveUrl = `https://www.cve.org/CVERecord?id=${cve}`;
                const cveStatus = release.CVEs[cve] ? '<span class="text-red-500 dark:text-red-500"> (Actively Exploited)</span>' : '';
                return `<a href="${createSafeLink(cveUrl)}" data-cve class="text-blue-600 dark:text-yellow-500 hover:text-blue-400 dark:hover:text-yellow-300" target="_blank">${cve}${cveStatus}</a>`;
            }).join(', ');

            const activelyExploitedCVEsHTML = release.ActivelyExploitedCVEs.length > 0 ?
                `<p class="text-gray-600 dark:text-gray-400">Actively Exploited Vulnerabilities (KEV): ` +
                release.ActivelyExploitedCVEs.map(cve => {
                    const kevUrl = `https://www.cisa.gov/known-exploited-vulnerabilities-catalog?search_api_fulltext=${cve}`;
                    return `<a href="${createSafeLink(kevUrl)}" data-cve class="text-blue-600 dark:text-yellow-500 hover:text-blue-400 dark:hover:text-yellow-300" target="_blank">${cve}</a>`;
                }).join(', ') + `</p>` : '';

            const releaseHTML = `
            <div class="${index > 0 ? 'border-t-2 border-gray-500 pt-4 mt-4' : ''} dark:border-gray-700">
              <p class="mt-1 max-w-2xl text-sm text-gray-600 dark:text-gray-400">Release Date: ${formatDate(release.ReleaseDate)}${warningSign}</p>
              <h3 class="text-lg leading-6 font-medium text-indigo-700 dark:text-yellow-500">${release.UpdateName}</h3>
              <p class="text-gray-600 dark:text-gray-400">Security Info: ${securityInfoHTML}</p>
              <p class="text-gray-600 dark:text-gray-400">Vulnerabilities Addressed: ${Object.keys(release.CVEs).length}</p>
              ${activelyExploitedCVEsHTML}
              <p class="text-gray-600 dark:text-gray-400">Security Advisories (CVE Identifiers): ${cveLinksHTML}</p>
              <p class="mt-1 max-w-2xl text-sm text-gray-600 dark:text-gray-400">Days to Prev. Release: ${release.DaysSincePreviousRelease}</p>
            </div>
        `;
            securityReleasesContainer.innerHTML += releaseHTML;
        });
    }


    function createSafeLink(url) {
        // Create a temporary anchor (a) element
        const tempAnchorElement = document.createElement('a');
        // Set the href attribute to the provided URL
        tempAnchorElement.href = url;
        // Return the sanitized href attribute value
        return tempAnchorElement.href;
    }

    function formatDate(dateString) {
        const options = {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        };
        return new Date(dateString).toLocaleDateString(undefined, options);
    }

    function initializeCVEFiltering() {
        const searchInput = document.getElementById('searchInput');
        searchInput.addEventListener('input', filterCVEs); // Setup the filter to respond to input
        filterCVEs(); // Apply the filter immediately in case there's an initial search term
    }

    let hideNoMatches = false; // Default behavior is to hide OS versions with no matching CVEs

    function filterCVEs() {
        const searchTerm = document.getElementById('searchInput').value.trim().toLowerCase();
        const securityReleasesContainer = document.getElementById('security-releases');
        const releaseContainers = securityReleasesContainer.querySelectorAll('div');

        if (!searchTerm) {
            // Reset visibility for all CVE links and containers when search is cleared
            resetSearchFiltering(releaseContainers);
            return; // Exit early if there is no search term
        }

        // Iterate over each release container
        releaseContainers.forEach(container => {
            let hasVisibleCVE = false; // Track if the container has any visible CVEs
            const cveLinks = container.querySelectorAll('[data-cve]'); // Get all CVE links within the container

            // Iterate over each CVE link to determine visibility
            cveLinks.forEach(link => {
                const match = link.textContent.toLowerCase().includes(searchTerm);
                if (match) {
                    link.classList.add('highlight-cve');
                    hasVisibleCVE = true; // Indicate that the container has a matching CVE
                } else {
                    link.classList.remove('highlight-cve');
                }
            });

            // Adjust the visibility of the container based on whether it has visible CVEs
            container.style.display = hasVisibleCVE ? '' : 'none';
        });
    }

    function resetSearchFiltering(releaseContainers) {
        // Function to reset the visibility of all CVE links and their containers
        releaseContainers.forEach(container => {
            container.style.display = ''; // Show all containers
            const cveLinks = container.querySelectorAll('[data-cve]');
            cveLinks.forEach(link => link.classList.remove('highlight-cve')); // Remove highlight from all CVE links
        });
    }
</script>

</body>
</html>
